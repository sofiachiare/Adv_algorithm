# -*- coding: utf-8 -*-
"""Naive_kruskal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fHFC1kZ99-S2Jq4Ffh8s7WcYqoU0Egpe

# Naive Kruskal Algorithm
"""

from ast import If
from operator import truediv
from time import perf_counter_ns
import gc
import math
import matplotlib.pyplot as plt
import os
from pathlib import Path
import tabulate

# class graph to rapresent graph


#class graph to rapresent graph
class Graph :
  def __init__(self, vertices, edges):
      #number of vertices in the graph
      self.V = vertices
      #number of edges in the graph
      self.E = edges
      #vertices1, vertices2, weight
      self.graph = []

  def add_edge(self, u, v, w):
        self.graph.append([u, v, w])

#function to create a graph from data
def create_graph(data):
  g = Graph(int(data[0][0]), int(data[0][1]))
  i = 1
  while(i < len(data)-1):
    values = data[i]
    g.add_edge(int(values[0]) - 1, int(values[1]) - 1, int(values[2]))
    i = i +1 
  return g


# implementation of Kruskal algorithm
def naive_kruskal_algo(g):
    tot_weight = 0
    result = []
    tempGraph = []

    # sort edges by weight
    g.graph = sorted(g.graph, key=lambda item: item[2])
    # print(g.graph)
    edg = 0
    while edg < g.E:  # for each edge e(v, w) do
        v, w, weight = g.graph[edg]  # take the edge informations
        edg = edg + 1
        # add to result the graph
        # if there is a cycle -> skip edge
        # else add edge
        # print("result:",result)
        result.append([v, w, weight])
        if len(tempGraph) == 0:
            tempGraph = createDFSGraph(result, g.V)
        else:
            addDFSEdge(tempGraph, v, w)

        # note the visited and unvisited nodes
        visited = [False] * g.V
        # print(tempGraph)
        if v != w:
            if not DFS_Traversal(tempGraph, v, visited):
                #print("not cycle")
                tot_weight += weight
            else:
                deleteDFSEdge(tempGraph, v, w)
                result.remove([v, w, weight])
        else:
            deleteDFSEdge(tempGraph, v, w)
            result.remove([v, w, weight])

    #print(tot_weight)
    #print("Result: ", result, "\n")
    return result, tot_weight


def createDFSGraph(result, vertice):
    # Adjacency list representation
    adjacencyList = [[] for _ in range(int(vertice))]

    for source, destination, weight in result:
        adjacencyList[source].append(destination)
        adjacencyList[destination].append(source)

    return adjacencyList


def addDFSEdge(adjacencyList, source, destination):
    adjacencyList[source].append(destination)
    adjacencyList[destination].append(source)
    return adjacencyList


def deleteDFSEdge(adjacencyList, source, destination):
    adjacencyList[source].remove(destination)
    adjacencyList[destination].remove(source)
    return adjacencyList

# Function for DFS_Traversal traversal
def DFS_Traversal(adjacencyList, v, visited, parent_node=-1):
 
    # assign current node as
    visited[v] = True
 
    # loop for every edge (v, u)
    for u in adjacencyList[v]:
 
        # if u is not visited
        if not visited[u]:
            if DFS_Traversal(adjacencyList, u, visited, v):
                return True
 
        # if u is visited, and u is not a parent_node
        elif u != parent_node:
            # found a back-edge 
            return True
 
    # No back-edges were found 
    return False


def plotResult(valone, valtwo, vertices):
    # sort the keys (number of vertices) of the dictionary and plot them
    plt.plot(vertices, valone, ':k')
    plt.plot(vertices, valtwo, 'r')
    plt.legend(["Measured time", "mn"])
    #plt.yscale("log")
    # x-axis label
    plt.xlabel('Number of Vertices')
    # frequency label
    plt.ylabel('Execution Time')
    # plot title
    plt.title('Kruskal Algorithm plot')
    # function to show the plot
    plt.show()


data_set = '/mst_dataset'
num_istances = 68
num_calls = 10
tentonine = 1000000000
#reading files
files = os.listdir(data_set)
files = sorted(files)
#weights of the MST
weights = []
total_time = 0.0

name = [] #name of files
complexity = []
vertices = []
all_runs = []
c = []
avg_c = 0

for filename in files:
  f = os.path.join(data_set, filename)
  if os.path.isfile(f):
      name.append(str(Path(f).stem))
      #read file and get the data
      file = open(f,'r')
      data = file.read().split("\n")
      for i in range(len(data) - 1):
        data[i] = data[i].split(" ")
      #creating the graph
      g = create_graph(data)

      #calculate times for one graph
      gc.disable()
      start_time = perf_counter_ns()
      for i in range(num_calls):
        r, w = naive_kruskal_algo(g)
      end_time = perf_counter_ns()
      gc.enable()
      #append the weight of result in the total list
      weights.append(w)
      #calculate the avg time for g
      run_times = ((end_time - start_time)/num_calls)/tentonine
      #append to a list with all the results
      all_runs.append(run_times)
      #compute the total time
      total_time += run_times


      #add the time taken corresponding to the number of nodes in a map for each graph to plot it at the end in a line chart

      c_estimate = run_times/float(g.V)
      c.append(c_estimate)
      #add c to the tmp var
      avg_c += c_estimate

      #calculate the asymptotic complexity
      mn = abs(int(g.E))*(abs(int(g.V)))
      complexity.append(mn)
      vertices.append(g.V)

      
avg_c = avg_c / num_istances

avg_time = (total_time / num_istances) 
ratios = [0] + [round(all_runs[i+1]/all_runs[i],3) for i in range(len(vertices)-1)]

print("Total time(s): ", total_time, " Average time (s): ", avg_time)
print("Average value of c used: ",avg_c)
print("                                                          ")

#--------------------------------------------------------------
#printing table size | run_times | m*n | C | ratio
zipSizeRunTimeAsyn = zip(vertices, all_runs, complexity, c, ratios)

tableSizeRunMN = tabulate(zipSizeRunTimeAsyn, headers=['Size(vertex)', 'Run Time(s)', 'Asyn Complexity', 'Constant', 'Ratio'], tablefmt='orgtbl')

print(tableSizeRunMN)

#--------------------------------------------------------------
print("                                                          ")
#--------------------------------------------------------------
#printing table file name | weight of results
zipNameWeight = zip(name, weights)

tableNameWeight = tabulate(zipNameWeight, headers=['Name of the file', 'Weight of MST'], tablefmt='orgtbl')

print(tableNameWeight)
print("                                                          ")
#--------------------------------------------------------------

reference = [avg_c * mn for mn in complexity]

plotResult(all_runs, reference, vertices)

#Plot just the mesured time

plt.plot(vertices, all_runs)

plt.legend(["Measured time"])

    # x-axis label
plt.xlabel('Number of Vertices')
    # frequency label
plt.ylabel('Execution Time')
    # plot title
plt.title('Kruskal Naive Algorithm plot')
    # function to show the plot
plt.show()