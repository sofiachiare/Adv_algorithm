# -*- coding: utf-8 -*-
"""Efficient_Kruskal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Pqo3RnAIVyzJXmH4NFnyzSj275wNzA8C

# Kruskal Algorithm using Union Find
"""

from time import perf_counter_ns
import gc
import math
import matplotlib.pyplot as plt
import os
from pathlib import Path
from tabulate import tabulate

#class UnionFind for datastructure
class UnionFind:
    parent = {}
    # stores the depth of trees
    rank = {}
 
    def init(self, n): 
        # create n (number of vertices) sets, I start from 1 because the vertices in graphs start with 1
        i = 1
        while i < n +1:
            self.parent[i] = i
            self.rank[i] = 0
            i = i + 1
 
    def find(self, k):
        # if `k` is the root
        if self.parent[k] == k:
          return k
        else: 
          self.parent[k] = self.find(self.parent[k])
          return self.parent[k]
         

    def union(self, a, b):
        # find the parents of the two vertices
        x = self.find(a)
        y = self.find(b)
 
        # if `x` and `y` are present in the same set => 
        if x == y:
            return
 
        # Always attach a smaller depth tree under the root of the deeper tree.
        if self.rank[x] > self.rank[y]:
            self.parent[y] = x
            self.rank[x] += self.rank[y]
        elif self.rank[x] < self.rank[y]:
            self.parent[x] = y
            self.rank[y] += self.rank[x]
        else:
            self.parent[x] = y
            self.rank[y] = self.rank[y] + 1

#class graph to rapresent graph
class Graph :
  def __init__(self, vertices, edges):
      #number of vertices in the graph
      self.V = vertices
      #number of edges in the graph
      self.E = edges
      #vertices1, vertices2, weight
      self.graph = []

  def add_edge(self, u, v, w):
        self.graph.append([u, v, w])

#function to create a graph from data
def create_graph(data):
  g = Graph(int(data[0][0]), int(data[0][1]))
  i = 1
  while(i < len(data)-1):
    values = data[i]
    g.add_edge(int(values[0]), int(values[1]), int(values[2]))
    i = i +1 
  return g


#implementation of Kruskal algorithm
def kruskal_algo(g):
  tot_weight = 0
  result = []
  #initialize UnionFind data structure
  u = UnionFind()
  u.init(g.V)
  #sort edges by weight
  g.graph = sorted(g.graph, key=lambda item: item[2])
  edg = 0 
  while edg < g.E: #for each edge e(v, w) do
    v, w, weight = g.graph[edg] #take the edge informations
    edg = edg + 1
    if u.find(v) != u.find(w):
      result.append([v, w, weight])
      u.union(v, w)
      tot_weight += weight
  return result, tot_weight

def plotResult(valone, valtwo, vertices):
    #sort the keys (number of vertices) of the dictionary and plot them
    plt.plot(vertices, valone ,':k')
    plt.plot(vertices, valtwo,'r')
    plt.legend(["Measured time" , "m(logn)"])
    plt.yscale("log")
    # x-axis label
    plt.xlabel('Number of Vertices')
    # frequency label
    plt.ylabel('Execution Time')
    # plot title
    plt.title('Kruskal Algorithm plot using UnionFind')
    # function to show the plot
    plt.show()
    

data_set = '/mst_dataset'
num_istances = 68
num_calls = 100
tentonine = 1000000000
#reading files
files = os.listdir(data_set)
files = sorted(files)
#weights of the MST
weights = []
total_time = 0.0

name = [] #name of files
complexity = []
vertices = []
all_runs = []
c = []
avg_c = 0

for filename in files:
  f = os.path.join(data_set, filename)
  if os.path.isfile(f):
      name.append(str(Path(f).stem))
      #read file and get the data
      file = open(f,'r')
      data = file.read().split("\n")
      for i in range(len(data) - 1):
        data[i] = data[i].split(" ")
      #creating the graph
      g = create_graph(data)

      #calculate times for one graph
      gc.disable()
      start_time = perf_counter_ns()
      for i in range(num_calls):
        r, w = kruskal_algo(g)
      end_time = perf_counter_ns()
      gc.enable()
      #append the weight of result in the total list
      weights.append(w)
      #calculate the avg time for g
      run_times = ((end_time - start_time)/num_calls)/tentonine
      #append to a list with all the results
      all_runs.append(run_times)
      #compute the total time
      total_time += run_times

      c_estimate = run_times/float(g.V)
      c.append(c_estimate)
      #add c to the tmp var
      avg_c += c_estimate

      #calculate the asymptotic complexity
      mlogn = abs(int(g.E))* math.log(abs(int(g.V)))
      complexity.append(mlogn)
      vertices.append(g.V)

      
avg_c = avg_c / num_istances

avg_time = (total_time / num_istances) 
ratios = [0] + [round(all_runs[i+1]/all_runs[i],3) for i in range(len(vertices)-1)]

print("Total time(s): ", total_time, " Average time (s): ", avg_time)
print("Average value of c used: ",avg_c)
print("                                                          ")

#--------------------------------------------------------------
#printing table size | run_times | mlogn | C | ratio
zipSizeRunTimeAsyn = zip(vertices, all_runs, complexity, c, ratios)

tableSizeRunMlogn = tabulate(zipSizeRunTimeAsyn, headers=['Size(vertex)', 'Run Time(s)', 'Asyn Complexity', 'Constant', 'Ratio'], tablefmt='orgtbl')

print(tableSizeRunMlogn)

#--------------------------------------------------------------
print("                                                          ")
#--------------------------------------------------------------
#printing table file name | weight of results
zipNameWeight = zip(name, weights)

tableNameWeight = tabulate(zipNameWeight, headers=['Name of the file', 'Weight of MST'], tablefmt='orgtbl')

print(tableNameWeight)
print("                                                          ")
#--------------------------------------------------------------

reference = [avg_c * mlogn for mlogn in complexity]

plotResult(all_runs, reference, vertices)

#Plot just the mesured time

plt.plot(vertices, all_runs)

plt.legend(["Measured time"])

    # x-axis label
plt.xlabel('Number of Vertices')
    # frequency label
plt.ylabel('Execution Time')
    # plot title
plt.title('Kruskal Algorithm plot using UnionFind')
    # function to show the plot
plt.show()




"""#Comparision Between Naive Kruskal, Prim and Efficient Kruskal"""

measuredTimePrim = [(10, 1.002788543701172e-05), (10, 1.996755599975586e-05), (10, 2.9914379119873047e-05), (10, 9.973049163818359e-06), (20, 4.986286163330078e-05), (20, 3.986358642578125e-05), (20, 1.9943714141845704e-05), (20, 2.9947757720947265e-05), (40, 9.008407592773437e-05), (40, 5.997657775878906e-05), (40, 7.007598876953125e-05), (40, 7.997989654541015e-05), (80, 0.00015958070755004884), (80, 9.970903396606445e-05), (80, 0.0001396465301513672), (80, 0.00018953084945678712), (100, 0.0002393627166748047), (100, 0.00017983913421630858), (100, 0.00017950057983398437), (100, 0.0001795172691345215), (200, 0.0003793525695800781), (200, 0.00047871828079223635), (200, 0.0003793144226074219), (200, 0.000498652458190918), (400, 0.0010272407531738282), (400, 0.0009177446365356446), (400, 0.001017153263092041), (400, 0.0009175038337707519), (800, 0.0022040963172912597), (800, 0.0021048235893249513), (800, 0.0019344735145568849), (800, 0.0030915665626525877), (1000, 0.0022454142570495607), (1000, 0.0020844197273254396), (1000, 0.001991763114929199), (1000, 0.0019032597541809083), (2000, 0.005027780532836914), (2000, 0.005095212459564209), (2000, 0.004643974304199219), (2000, 0.004832005500793457), (4000, 0.015464627742767334), (4000, 0.015766913890838622), (4000, 0.013168997764587402), (4000, 0.011539134979248047), (8000, 0.026810703277587892), (8000, 0.026185805797576903), (8000, 0.025224740505218505), (8000, 0.024347643852233886), (10000, 0.037473807334899904), (10000, 0.031796021461486815), (10000, 0.029661247730255125), (10000, 0.03320180892944336), (20000, 0.07590766429901123), (20000, 0.07419640064239502), (20000, 0.08361054182052613), (20000, 0.08053056478500366), (40000, 0.15154582262039185), (40000, 0.15955180406570435), (40000, 0.1590648126602173), (40000, 0.1528717064857483), (80000, 0.3369351506233215), (80000, 0.3514390230178833), (80000, 0.35799886226654054), (80000, 0.34812422513961794), (100000, 0.43697901964187624), (100000, 0.4565686631202698), (100000, 0.47695388078689577), (100000, 0.4361734485626221)]

all_runsNaive=  [0.000298, 0.0003164, 0.0003139, 0.0002559, 0.0003762, 0.0004368, 0.000427, 0.000394, 0.0005329, 0.0007831, 0.001205, 0.0013725, 0.001765, 0.0021124, 0.0010901, 0.0021982, 0.002974, 0.0020709, 0.0014648, 0.0018278, 0.0042428, 0.0069469, 0.0049505, 0.008935, 0.0282049, 0.0196311, 0.0313372, 0.0236253, 0.0850228, 0.0797528, 0.0922996, 0.08383, 0.108676, 0.1182441, 0.1145916, 0.1315622, 0.477197, 0.4102249, 0.4518671, 0.4568875, 1.8182269, 1.9202706, 1.8574047, 1.9113264, 8.4173669, 9.5686147, 9.48551, 9.5092043, 15.9919326, 16.1617221, 16.5219142, 16.6477986, 74.3197957, 98.103375, 100.0921511, 100.7123217, 386.178182, 416.8170281, 411.0875007, 418.8519159, 1315.6854547, 1380.3935569, 1504.5225164, 1454.4442824, 2405.9012914, 2652.26179, 2543.3213903, 2327.4033665]


#Plot  the mesured time of Prim and Kruskal in a log scale

plt.plot(vertices, all_runs)
plt.plot(*zip(*sorted(measuredTimePrim) ))
plt.plot(vertices, all_runsNaive)
plt.legend(["Efficient Kruskal" , "Prim","Naive Kruskal"])
plt.yscale("log")
    # x-axis label
plt.xlabel('Number of Vertices')
    # frequency label
plt.ylabel('Execution Time')
    # plot title
plt.title('Comparison between three algorithm(log scale)')
    # function to show the plot
plt.show()

#Plot  the mesured time of Prim and Kruskal 

plt.plot(vertices, all_runs)
plt.plot(*zip(*sorted(measuredTimePrim) ))
plt.plot(vertices, all_runsNaive)
plt.legend(["Efficient Kruskal" , "Prim","Naive Kruskal"])
    # x-axis label
plt.xlabel('Number of Vertices')
    # frequency label
plt.ylabel('Execution Time')
    # plot title
plt.title('Comparison between three algorithm')
    # function to show the plot
plt.show()

"""## Plotting Prim Vs Efficient Kruskal

"""

plt.plot(vertices, all_runs)
plt.plot(*zip(*sorted(measuredTimePrim) ))
plt.legend(["Efficient Kruskal" , "Prim"])
    # x-axis label
plt.xlabel('Number of Vertices')
    # frequency label
plt.ylabel('Execution Time')
    # plot title
plt.title('Comparison between Prim and Efficient Kruskal')
    # function to show the plot
plt.show()

"""#Naive Kruskal Graph (For testing purposes)"""

naivekruskal=  [0.000298, 0.0003164, 0.0003139, 0.0002559, 0.0003762, 0.0004368, 0.000427, 0.000394, 0.0005329, 0.0007831, 0.001205, 
0.0013725, 0.001765, 0.0021124, 0.0010901, 0.0021982, 0.002974, 0.0020709, 0.0014648, 0.0018278, 0.0042428, 0.0069469, 0.0049505, 0.008935, 0.0282049, 0.0196311, 0.0313372, 0.0236253, 0.0850228, 0.0797528, 0.0922996, 0.08383, 0.108676, 0.1182441, 0.1145916, 0.1315622, 0.477197, 0.4102249, 0.4518671, 0.4568875, 1.8182269, 1.9202706, 1.8574047, 1.9113264, 8.4173669, 9.5686147, 9.48551, 9.5092043, 15.9919326, 16.1617221, 16.5219142, 16.6477986, 74.3197957, 98.103375, 100.0921511, 100.7123217, 386.178182, 416.8170281, 411.0875007, 418.8519159, 1315.6854547, 1380.3935569, 1504.5225164, 1454.4442824, 2405.9012914, 2652.26179, 2543.3213903, 2327.4033665]
mn=  [0.3244546315482353, 0.39655566078117643, 0.4686566900141176, 0.36050514616470586, 1.730424701590588, 1.730424701590588, 2.0188288185223526, 1.8746267600564703, 8.07531527408941, 7.210102923294117, 7.210102923294117, 7.498507040225881, 31.147644628630584, 28.5520075762447, 29.994028160903525, 32.87806933022117, 49.0286998784, 46.505163855247055, 49.3892050245647, 47.58667929374117, 192.50974805195293, 193.95176863661175, 193.95176863661175, 192.50974805195293, 778.6911157157646, 746.9666628532705, 775.807074546447, 758.5028275305411, 3065.7357629846583, 3051.3155571380703, 3103.228298185788, 3025.3591866142115, 4686.566900141176, 4733.432569142587, 4787.508341067293, 4845.189164453646, 19460.06778997082, 19135.613158422588, 19121.192952576, 19301.44552565835, 77292.30333771293, 76643.39407461646, 77003.89922078117, 77407.66498448564, 308736.6071754541, 307727.1927661929, 307496.46947264747, 310236.3085834993, 479507.89491367526, 480913.8649837176, 479003.18770904467, 479868.40005983994, 1922718.1465548421, 1934182.2102028797, 1923150.7527302399, 1922934.449642541, 7702552.952955105, 7707023.216767548, 7677605.996840508, 7688709.55534238, 30834437.75764269, 30753396.200784862, 30739841.20728907, 30730612.275547255, 48089583.97264094, 48024332.541185126, 48136089.136496186, 48114098.32258014]
vertices=  [10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 40, 40, 80, 80, 80, 80, 100, 100, 100, 100, 200, 200, 200, 200, 400, 400, 400, 400, 800, 800, 800, 800, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 4000, 4000, 4000, 4000, 8000, 8000, 8000, 8000, 10000, 10000, 10000, 10000, 20000, 20000, 20000, 20000, 40000, 40000, 40000, 40000, 80000, 80000, 80000, 80000, 100000, 100000, 100000, 100000]
measuredTimePrim = [(10, 1.002788543701172e-05), (10, 1.996755599975586e-05), (10, 2.9914379119873047e-05), (10, 9.973049163818359e-06), (20, 4.986286163330078e-05), (20, 3.986358642578125e-05), (20, 1.9943714141845704e-05), (20, 2.9947757720947265e-05), (40, 9.008407592773437e-05), (40, 5.997657775878906e-05), (40, 7.007598876953125e-05), (40, 7.997989654541015e-05), (80, 0.00015958070755004884), (80, 9.970903396606445e-05), (80, 0.0001396465301513672), (80, 0.00018953084945678712), (100, 0.0002393627166748047), (100, 0.00017983913421630858), (100, 0.00017950057983398437), (100, 0.0001795172691345215), (200, 0.0003793525695800781), (200, 0.00047871828079223635), (200, 0.0003793144226074219), (200, 0.000498652458190918), (400, 0.0010272407531738282), (400, 0.0009177446365356446), (400, 0.001017153263092041), (400, 0.0009175038337707519), (800, 0.0022040963172912597), (800, 0.0021048235893249513), (800, 0.0019344735145568849), (800, 0.0030915665626525877), (1000, 0.0022454142570495607), (1000, 0.0020844197273254396), (1000, 0.001991763114929199), (1000, 0.0019032597541809083), (2000, 0.005027780532836914), (2000, 0.005095212459564209), (2000, 0.004643974304199219), (2000, 0.004832005500793457), (4000, 0.015464627742767334), (4000, 0.015766913890838622), (4000, 0.013168997764587402), (4000, 0.011539134979248047), (8000, 0.026810703277587892), (8000, 0.026185805797576903), (8000, 0.025224740505218505), (8000, 0.024347643852233886), (10000, 0.037473807334899904), (10000, 0.031796021461486815), (10000, 0.029661247730255125), (10000, 0.03320180892944336), (20000, 0.07590766429901123), (20000, 0.07419640064239502), (20000, 0.08361054182052613), (20000, 0.08053056478500366), (40000, 0.15154582262039185), (40000, 0.15955180406570435), (40000, 0.1590648126602173), (40000, 0.1528717064857483), (80000, 0.3369351506233215), (80000, 0.3514390230178833), (80000, 0.35799886226654054), (80000, 0.34812422513961794), (100000, 0.43697901964187624), (100000, 0.4565686631202698), (100000, 0.47695388078689577), (100000, 0.4361734485626221)]


#Plot  the mesured time of Naive

plt.plot(vertices, naivekruskal)
plt.plot(vertices, mn)
plt.yscale("log")

plt.legend(["Measured Time","m*n"])

    # x-axis label
plt.xlabel('Number of Vertices')
    # frequency label
plt.ylabel('Execution Time')
    # plot title
plt.title('Kruskal Algorithms (without Union Find)')
    # function to show the plot
plt.show()

#Plot  the mesured time of Naive Kruskal

plt.plot(vertices, naivekruskal)

plt.legend(["Measured Time"])

    # x-axis label
plt.xlabel('Number of Vertices')
    # frequency label
plt.ylabel('Execution Time')
    # plot title
plt.title('Kruskal Algorithms (without Union Find)')
    # function to show the plot
plt.show()